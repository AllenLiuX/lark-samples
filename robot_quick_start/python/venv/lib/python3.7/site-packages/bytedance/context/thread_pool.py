# coding: utf-8

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals


import copy
import functools
from multiprocessing.pool import ThreadPool as OriginThreadPool

from .context import global_context


def wrap_context(fn):
    context_store = copy.deepcopy(getattr(global_context.thread_local, "store", {}))
    @functools.wraps(fn)
    def wrapped(*args, **kwargs):
        global_context.thread_local.store = context_store
        return fn(*args, **kwargs)
    return wrapped


class ThreadPool(OriginThreadPool):
    """Drop-in replacement for ``multiprocessing.dummy.Pool``, which will pass context to new thread.
    """
    def apply(self, func, *args, **kwargs):
        return super(ThreadPool, self).apply(wrap_context(func), *args, **kwargs)

    def map(self, func, *args, **kwargs):
        return super(ThreadPool, self).map(wrap_context(func), *args, **kwargs)

    def map_async(self, func, *args, **kwargs):
        return super(ThreadPool, self).map_async(wrap_context(func), *args, **kwargs)

    def imap(self, func, *args, **kwargs):
        return super(ThreadPool, self).imap(wrap_context(func), *args, **kwargs)

    def imap_unordered(self, func, *args, **kwargs):
        return super(ThreadPool, self).imap_unordered(wrap_context(func), *args, **kwargs)
