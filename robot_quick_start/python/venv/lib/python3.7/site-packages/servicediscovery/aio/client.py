import ipaddress
import os
import sys
import time
import json
import asyncio
import warnings
from typing import Optional, Dict, List, Tuple

import aiohttp

try:
    from contextlib import asynccontextmanager
except ImportError:
    from async_generator import asynccontextmanager

from ..client import Client as BaseClient, Endpoint, HEADER_CONSUL_HASH
from ..error import ServiceDiscoveryError


class Client(BaseClient):
    async def lookup(
        self, name: str, timeout: int = 3, cachetime: int = 0, cluster: Optional[str] = None,
        address_family: Optional[str] = None, dualstack_unique: Optional[str] = None
    ) -> List[Endpoint]:
        self.check_address_family(address_family)
        self.check_dualstack_unique(address_family, dualstack_unique)

        cache_key = self._cache_key(name, cluster, address_family, dualstack_unique)
        now = time.time()
        cache = self._cache.get(cache_key)
        if cachetime > 0 and cache and now - cache["updatetime"] <= cachetime:
            return cache["ret"]

        try:
            ret, consul_hash = await self._lookup(name, timeout, cluster, cache, address_family, dualstack_unique)
        except (ServiceDiscoveryError, aiohttp.ClientError, asyncio.CancelledError):
            if cache:
                print("[servicediscovery] got consul agent error, using cached result!", file=sys.stderr)
                return cache["ret"]
            raise

        ret = list(map(Endpoint, ret))

        self._cache.put(cache_key, {"ret": ret, "consul_hash": consul_hash, "updatetime": now})
        return ret

    async def _lookup(self, name: str, timeout: int, cluster: str, cache: Optional[dict] = None,
                      address_family: Optional[str] = None, dualstack_unique: Optional[str] = None) -> Tuple[list, str]:
        url = "/v1/lookup/name?name=" + name
        if cluster:
            url += "&cluster=" + cluster

        address_family = address_family or self._address_family
        dualstack_unique = dualstack_unique or self._dualstack_unique
        if address_family:
            url += "&addr-family=" + address_family
            if dualstack_unique:
                url += "&unique=" + dualstack_unique

        headers = {}
        if cache and cache["consul_hash"]:
            headers[HEADER_CONSUL_HASH] = cache["consul_hash"]
        async with self._request(
            "GET", self._consul_host, self._consul_port, url, headers=headers, timeout=timeout
        ) as r:
            headers = r.headers
            status = r.status
            data = await r.read()
        if status == 304:
            return cache["ret"], cache["consul_hash"]
        elif status != 200:
            raise ServiceDiscoveryError(data.decode("utf8"))
        consul_hash = headers[HEADER_CONSUL_HASH]
        return json.loads(data.decode("utf8")), consul_hash

    @asynccontextmanager
    async def _request(
        self,
        method: str,
        host: str,
        port: int,
        path: str,
        timeout: int,
        headers: Optional[Dict[str, str]] = None,
        body: Optional[str] = None,
    ) -> aiohttp.ClientResponse:
        if host.startswith("/"):
            conn = aiohttp.UnixConnector(path=host)
            host = "localhost"
        else:
            conn = None
        async with aiohttp.ClientSession(connector=conn) as s:
            try:
                parsed_addr = ipaddress.ip_address(host)
                if isinstance(parsed_addr, ipaddress.IPv6Address):
                    host = f"[{host}]"
            except ValueError:
                # parsing error, skip adding "[]" and go forward
                pass

            async with s.request(
                method,
                "http://{host}:{port}{path}".format(host=host, port=port, path=path),
                timeout=timeout,
                headers=headers,
                data=body,
            ) as r:
                yield r

    async def register(
        self,
        name: str,
        port: int,
        tags: Dict[str, str] = None,
        check_script: Optional[str] = None,
        host: Optional[str] = None,
    ):
        warnings.warn("register is deprecated, don't use it any more!")

        d = {"id": "%s-%s" % (name, port), "name": name, "port": int(port)}
        if tags is not None:
            d["tags"] = ["%s:%s" % (k, v) for k, v in tags.items()]
        if check_script:
            d["check"] = {"interval": "30s", "script": check_script}
        async with self._request(
            "PUT",
            host or self._consul_host,
            self._consul_port,
            "/v1/agent/service/register",
            body=json.dumps(d),
            timeout=3,
        ) as r:
            if r.status != 200:
                raise ServiceDiscoveryError((await r.read()).decode("utf8"))

    async def deregister(self, name: str, port: int, host: Optional[str] = None):
        warnings.warn("deregister is deprecated, don't use it any more!")

        async with self._request(
            "PUT",
            host or self._consul_host,
            self._consul_port,
            "/v1/agent/service/deregister/%s-%s" % (name, port),
            timeout=10,
        ) as r:
            if r.status != 200:
                raise ServiceDiscoveryError((await r.read()).decode("utf8"))

    async def get_one(
        self, name: str, timeout: int = 3, cachetime: int = 10, cluster: Optional[str] = None,
        address_family: Optional[str] = None, dualstack_unique=None, env: str = None, envs: List[str] = None
    ) -> Endpoint:
        hosts = await self.lookup(name, timeout, cachetime, cluster, address_family, dualstack_unique)
        return self._get_one(hosts, name, env=env, envs=envs)

    async def lookup_name(self, name, timeout=3, cachetime=10, cluster=None) -> List[Endpoint]:
        ipv4 = os.getenv("BYTED_HOST_IP")
        ipv6 = os.getenv("BYTED_HOST_IPV6")
        if ipv4 and ipv6:
            return await self.lookup(name, timeout, cachetime, cluster, "dual-stack", "v6")
        elif ipv6:
            return await self.lookup(name, timeout, cachetime, cluster, "v6")
        elif ipv4:
            return await self.lookup(name, timeout, cachetime, cluster, "v4")
        return await self.lookup(name, timeout, cachetime, cluster)

    async def get_one_name(self, name, timeout=3, cachetime=10, cluster=None, env=None, envs=None) -> Endpoint:
        hosts = await self.lookup_name(name, timeout, cachetime, cluster)
        return self._get_one(hosts, name, env=env, envs=envs)


client = Client()
set_address_family = client.set_address_family
set_dualstack_unique = client.set_dualstack_unique
lookup = client.lookup
lookup_name = client.lookup_name
register = client.register
deregister = client.deregister
get_one = client.get_one
get_one_name = client.get_one_name
