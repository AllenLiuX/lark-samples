# coding: utf-8

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import socket

from six.moves.urllib.parse import urlparse, urlunparse

from requests.adapters import HTTPAdapter as BaseHTTPAdapter

from .error import ServiceDiscoveryError
from .client import get_one_name, get_egress_mesh_addr

import bytedance.context


def is_ipv6(ip):
    try:
        socket.inet_pton(socket.AF_INET6, ip)
    except socket.error:
        return False
    return True


def _consul_endpoint_to_ip_port(ed):
    ip = ed["Host"]
    port = ed["Port"]
    if is_ipv6(ip):
        ip = "[%s]" % ip
    return "%s:%s" % (ip, port)


def parse_url(url, **kwargs):
    """
    parse url with sd scheme such as "sd://p.s.m/path/to" or "sd+http://psm/path/to".
    :param url: The URL need to parse.
    :rtype: str
    """
    parsed = urlparse(url)  # type: ParseResult
    if "+" in parsed.scheme:
        scheme, sub_scheme = parsed.scheme.split("+")
    else:
        scheme = "http"
        sub_scheme = ""

    if not sub_scheme == "sd":
        return url

    env = bytedance.context.get("env")
    if env == "prod":
        envs = [env, "canary", "", None]
        ins = get_one_name(parsed.netloc, envs=envs, **kwargs)
    else:
        try:
            ins = get_one_name(parsed.netloc, env=env, **kwargs)
        except ServiceDiscoveryError:
            ins = get_one_name(parsed.netloc, envs=["prod", "", None], **kwargs)

    _replace = parsed._replace(
        scheme=scheme, netloc="%s" % _consul_endpoint_to_ip_port(ins)
    )
    return urlunparse(_replace)


def parse_mesh_url(url):
    parsed = urlparse(url)
    # mesh port just support http protocol
    # (mesh will use https protocol to access target if we specify "destination-protocol" header be "https")
    _replace = parsed._replace(scheme="http", netloc="%s" % get_egress_mesh_addr())
    return urlunparse(_replace)


class HTTPAdapter(BaseHTTPAdapter):
    def __init__(self, parse_kwargs=None, enable_mesh=False, **kwargs):
        self.enable_mesh = enable_mesh
        if parse_kwargs:
            self.parse_kwargs = parse_kwargs
        else:
            self.parse_kwargs = {}
        super(HTTPAdapter, self).__init__(**kwargs)

    def get_connection(self, url, proxies=None):
        """
        :param url: The URL to connect to. eg: sd://p.s.m/path/to.
        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.
        :rtype: urllib3.ConnectionPool
        """
        if self.enable_mesh:
            return super(HTTPAdapter, self).get_connection(
                parse_mesh_url(url, **self.parse_kwargs), proxies
            )

        return super(HTTPAdapter, self).get_connection(
            parse_url(url, **self.parse_kwargs), proxies
        )
