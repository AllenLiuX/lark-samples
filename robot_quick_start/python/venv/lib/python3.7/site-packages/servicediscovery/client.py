# coding: utf-8

"""consul based service discovery client
"""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import bisect as _bisect
import json
import os
import random
import socket
import sys
import time
import warnings

from contextlib import contextmanager

import six
from six.moves.http_client import HTTPConnection
from six.moves.http_client import HTTPException

import bytedance.context

from .cache import Cache
from .error import ServiceDiscoveryError

HEADER_CONSUL_HASH = "X-Consul-Result-Hash"


class UnixHTTPConnection(HTTPConnection):
    def __init__(self, path, **kwargs):
        kwargs["host"] = "localhost"
        HTTPConnection.__init__(self, **kwargs)
        self.path = path

    def connect(self):
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(self.path)
        self.sock = sock


def is_unix_sock_available(path):
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect(path)
        return True
    except Exception:
        return False
    finally:
        sock.close()


if hasattr(random, "choices"):

    def weight_choices(population, weights):
        return random.choices(population, weights=weights)[0]


else:

    def accumulate(array):
        n = len(array)
        for i in range(1, n):
            array[i] += array[i - 1]
        return array

    def weight_choices(population, weights):
        cum_weights = accumulate(weights)

        if len(cum_weights) != len(population):
            raise ValueError("The number of weights does not match the population")
        bisect = _bisect.bisect
        total = cum_weights[-1]
        return population[bisect(cum_weights, random.random() * total)]


def is_enable_egress_mesh():
    if os.getenv("TCE_ENABLE_HTTP_SIDECAR_EGRESS") == "True" and os.getenv("WITH_HTTP_MESH_EGRESS_UDS") != "True":
        return True

    return False


def get_egress_mesh_addr():
    return "127.0.0.1:{}".format(os.getenv("MESH_EGRESS_PORT"))


def inject_header_from_ctx(headers):
    if not headers:
        headers = {}
    else:
        headers = headers.copy()

    # ref: https://code.byted.org/pylibs/bytedwsgimiddleware/blob/master/bytedwsgimiddleware/api.py#L204
    if bytedance.context.get("logid"):
        headers["x-tt-logid"] = bytedance.context.get("logid")

    if bytedance.context.get("env"):
        headers["x-tt-env"] = bytedance.context.get("env")

    if bytedance.context.get("stress_tag"):
        headers["x-tt-stress"] = bytedance.context.get("stress_tag")

    for k in bytedance.context.global_context:
        if k.isupper():
            headers["rpc-persist-{}".format(k.replace("_", "-").lower())] = bytedance.context.get(k)

    return headers


class Endpoint(dict):
    """endpoint object, describe one pod for the PSM, include host, port and tags attributes.
    """

    @property
    def host(self):
        """
        Host of current endpoint.

        :rtype: str
        """
        return self["Host"]

    @property
    def port(self):
        """
        Port of current endpoint.

        :rtype: int
        """
        return self["Port"]

    @property
    def tags(self):
        """
        Tags of current endpoint.

        e.g.

        .. code:: python

            {
                'PORT1': '9361',
                'cluster': 'default',
                'env': 'canary',
                'kind': 'pod',
                'mesh': '1',
                'weight': '10'
            }

        :rtype: dict
        """
        return self["Tags"]


class Client(object):
    def __init__(self, address_family=None, dualstack_unique=None):
        self.set_address_family(address_family)
        self.set_dualstack_unique(dualstack_unique)
        self._cache = Cache()
        self._consul_host = self.get_host()
        self._consul_port = int(os.environ.get("CONSUL_HTTP_PORT") or 2280)

    @staticmethod
    def get_host():
        path = os.environ.get("BYTED_SD_UDS_PATH")
        if path and os.path.exists(path) and is_unix_sock_available(path):
            return path
        sock = "/opt/tmp/sock/consul.sock"
        host = (
            os.environ.get("CONSUL_HTTP_HOST") or
            os.environ.get("TCE_HOST_IP") or
            os.environ.get("MY_HOST_IP") or
            os.environ.get("MY_HOST_IPV6")
        )

        if host:
            return host
        if os.path.exists(sock) and is_unix_sock_available(sock):
            return sock
        return "127.0.0.1"

    @staticmethod
    def check_address_family(address_family):
        if address_family is not None and not isinstance(address_family, six.string_types):
            raise ValueError('invalid address_family')
        elif address_family and address_family not in {'v4', 'v6', 'dual-stack'}:
            raise ValueError('invalid address_family')

    @staticmethod
    def check_dualstack_unique(address_family, dualstack_unique):
        if dualstack_unique and address_family != 'dual-stack':
            raise ValueError('invalid address_family for dualstack_unique')
        if dualstack_unique and dualstack_unique not in {'v6', 'v4'}:
            raise ValueError('invalid dualstack_unique')

    def set_address_family(self, address_family):
        self.check_address_family(address_family)
        self._address_family = address_family

    def set_dualstack_unique(self, dualstack_unique):
        self.check_dualstack_unique(self._address_family, dualstack_unique)
        self._dualstack_unique = dualstack_unique

    def get_address_family(self):
        return self._address_family

    def get_dualstack_unique(self):
        return self._dualstack_unique

    def lookup(self, name, timeout=3, cachetime=10, cluster=None, address_family=None, dualstack_unique=None):
        """
        查询某个服务的注册信息。

          **注意**：如果查询结果为空，则返回空列表，而不是抛出异常，调用方需要检查这种情况。

        :param name: 需要查询的目标（PSM）
        :type name: str
        :param timeout: 查询的超时
        :type timeout: int
        :param cachetime: 查询结果缓存时常，默认为 10s
        :type cachetime: int
        :param cluster: 查询的集群
        :type cluster: str
        :param address_family: 服务发现ip协议
        :type address_family: str
        :return: 查询结果，为包含 Endpoint(兼容dict) 类型数据的 list，样例：

                 .. code:: python

                           [{'Host': '192.168.1.11',
                             'Port': 9311,
                             'Tags': {'PORT1': '9312',
                                      'cluster': 'default',
                                      'env': 'prod',
                                      'kind': 'pod',
                                      'mesh': '1',
                                      'weight': '10'}},
                            {'Host': '192.168.1.12',
                             'Port': 9360,
                             'Tags': {'PORT1': '9361',
                                      'cluster': 'default',
                                      'env': 'canary',
                                      'kind': 'pod',
                                      'mesh': '1',
                                      'weight': '10'}}]

        :rtype: list
        :raise ServiceDiscoveryError: 调用请求 consul agent，返回状态码非 200, 304 时抛出
        :raise ConnectionRefusedError: 连接 consul agent 失败时抛出，如果为 macOS 开发环境，请尝试设置 ``CONSUL_HTTP_HOST`` 环境变量解决
        """
        self.check_address_family(address_family)
        self.check_dualstack_unique(address_family, dualstack_unique)
        cache_key = self._cache_key(name, cluster, address_family, dualstack_unique)
        now = time.time()
        cache = self._cache.get(cache_key)
        if cachetime > 0 and cache and now - cache["updatetime"] <= cachetime:
            return cache["ret"]
        try:
            ret, consul_hash = self._lookup(name, timeout, cluster, cache, address_family, dualstack_unique)
        except (ServiceDiscoveryError, HTTPException, socket.error):
            if cache:
                print("[servicediscovery] got consul agent error, using cached result!", file=sys.stderr)
                return cache["ret"]
            raise

        ret = list(map(Endpoint, ret))

        self._cache.put(cache_key, {"ret": ret, "consul_hash": consul_hash, "updatetime": now})
        return ret

    @staticmethod
    def _cache_key(name, cluster, address_family=None, dualstack_unique=None):
        """
        key format is (name, cluster, address_family, dualstack_unique)
        """
        return name, cluster, address_family, dualstack_unique

    @contextmanager
    def _request(self, method, host, port, path, timeout, headers=None, body=None):
        requested = False
        if host.startswith("/"):
            conn = UnixHTTPConnection(host)
            try:
                conn.request(method, path, headers=headers or {}, body=body)
                requested = True
            except Exception:
                host = self.get_host()
                if not host.startswith("/"):
                    conn = HTTPConnection(host, port, timeout=timeout)
        else:
            conn = HTTPConnection(host, port, timeout=timeout)

        if not requested:
            conn.request(method, path, headers=headers or {}, body=body)
        response = conn.getresponse()
        try:
            yield response
        finally:
            conn.close()

    def _lookup(self, name, timeout, cluster, cache=None, address_family=None, dualstack_unique=None):
        url = "/v1/lookup/name?name=" + name
        if cluster:
            url += "&cluster=" + cluster

        address_family = address_family or self._address_family
        dualstack_unique = dualstack_unique or self._dualstack_unique
        if address_family:
            url += "&addr-family=" + address_family
            if dualstack_unique:
                url += "&unique=" + dualstack_unique

        headers = {}
        if cache and cache["consul_hash"]:
            headers[HEADER_CONSUL_HASH] = cache["consul_hash"]

        with self._request(
            "GET", self._consul_host, self._consul_port, url, headers=headers, timeout=timeout
        ) as response:
            status = response.status
            data = response.read()
            if status == 304:
                return cache["ret"], cache["consul_hash"]
            elif status != 200:
                raise ServiceDiscoveryError(data.decode("utf8"))

            consul_hash = response.getheader(HEADER_CONSUL_HASH)
        return json.loads(data.decode("utf8")), consul_hash

    def register(self, name, port, tags=None, check_script=None, host=None):
        """
        进行服务注册，正常情况下服务注册应由平台容易注册，一般用户不需要调用此方法。

        :param name: 需要注册的服务名称（PSM）
        :type name: str
        :param port: 注册的端口
        :type port: int
        :param tags: 需要注册的 tags
        :type tags: dict
        :param check_script: 健康检查脚本
        :type check_script: str
        :param host: 要注册的服务地址
        :type host: str
        :rtype: None
        :raise ServiceDiscoveryError: 调用请求 consul agent，返回状态码非 200 时抛出
        :raise ConnectionRefusedError: 连接 consul agent 失败时抛出，如果为 macOS 开发环境，请尝试设置 ``CONSUL_HTTP_HOST`` 环境变量解决
        """
        warnings.warn("register is deprecated, don't use it any more!")

        d = {"id": "%s-%s" % (name, port), "name": name, "port": int(port)}
        if tags is not None:
            d["tags"] = ["%s:%s" % (k, v) for k, v in tags.items()]
        if check_script:
            d["check"] = {"interval": "30s", "script": check_script}
        with self._request(
            "PUT",
            host or self._consul_host,
            self._consul_port,
            "/v1/agent/service/register",
            body=json.dumps(d),
            timeout=3,
        ) as response:
            status = response.status
            data = response.read()
        if status != 200:
            raise ServiceDiscoveryError(data.decode("utf8"))

    def deregister(self, name, port, host=None):
        """
        进行服务解注册，正常情况下服务注册应由平台容易注册，一般用户不需要调用此方法。

        :param name: 需要解注册的服务名称（PSM）
        :type name: str
        :param port: 解注册的端口
        :type port: int
        :param host: 要解注册的服务地址
        :type host: str
        :rtype: None
        :raise ServiceDiscoveryError: 调用请求 consul agent，返回状态码非 200 时抛出
        :raise ConnectionRefusedError: 连接 consul agent 失败时抛出，如果为 macOS 开发环境，请尝试设置 ``CONSUL_HTTP_HOST`` 环境变量解决
        """
        warnings.warn("deregister is deprecated, don't use it any more!")

        with self._request(
            "PUT",
            host or self._consul_host,
            self._consul_port,
            "/v1/agent/service/deregister/%s-%s" % (name, port),
            timeout=10,
        ) as response:
            status = response.status
            data = response.read()
        if status != 200:
            raise ServiceDiscoveryError(data.decode("utf8"))

    def get_one(self, name, timeout=3, cachetime=10, cluster=None, address_family=None, dualstack_unique=None,
                env=None, envs=None):
        """
        获取某个服务的单个地址，带权重的随机返回一个。

        :param name: 需要查询的目标（PSM）
        :type name: str
        :param timeout: 查询的超时
        :type timeout: int
        :param cachetime: 查询结果缓存时常，默认为 10s
        :type cachetime: int
        :param cluster: 查询的集群
        :type cluster: str
        :param address_family: 服务发现ip协议
        :type address_family: str
        :param dualstack_unique: address_family=dual-stack时，选取的ip协议
        :type dualstack_unique: str
        :param env: 要查询的目标的 env
        :type env: str
        :param envs: 要查询的目标的 env 列表
        :type envs: list[str]
        :return:
                 .. code:: python

                           {'Host': '192.168.1.21',
                             'Port': 9311,
                             'Tags': {'PORT1': '9312',
                                      'cluster': 'default',
                                      'env': 'prod',
                                      'kind': 'pod',
                                      'mesh': '1',
                                      'weight': '10'}
        :rtype: Endpoint
        :raise ServiceDiscoveryError: 调用请求 consul agent，返回状态码非 200 时抛出，服务列表为空也会抛出
        :raise ConnectionRefusedError: 连接 consul agent 失败时抛出，如果为 macOS 开发环境，请尝试设置 ``CONSUL_HTTP_HOST`` 环境变量解决
        """
        hosts = self.lookup(name, timeout, cachetime, cluster, address_family, dualstack_unique)
        return self._get_one(hosts, name, env=env, envs=envs)

    def lookup_name(self, name, timeout=3, cachetime=10, cluster=None):
        ipv4 = os.getenv("BYTED_HOST_IP")
        ipv6 = os.getenv("BYTED_HOST_IPV6")
        if ipv4 and ipv6:
            return self.lookup(name, timeout, cachetime, cluster, "dual-stack", "v6")
        elif ipv6:
            return self.lookup(name, timeout, cachetime, cluster, "v6")
        elif ipv4:
            return self.lookup(name, timeout, cachetime, cluster, "v4")
        return self.lookup(name, timeout, cachetime, cluster)

    def get_one_name(self, name, timeout=3, cachetime=10, cluster=None, env=None, envs=None):
        """
        获取某个服务的单个地址，带权重的随机返回一个。与 get_one 作用相同，区别是尊重环境变量中的 IPV4/6 设置。

        :param name: 需要查询的目标（PSM）
        :type name: str
        :param timeout: 查询的超时
        :type timeout: int
        :param cachetime: 查询结果缓存时常，默认为 10s
        :type cachetime: int
        :param cluster: 查询的集群
        :type cluster: str
        :param env: 要查询的目标的 env
        :type env: str
        :param envs: 要查询的目标的 env 列表
        :type envs: list[str]
        :return:
                 .. code:: python

                           {'Host': '192.168.1.21',
                             'Port': 9311,
                             'Tags': {'PORT1': '9312',
                                      'cluster': 'default',
                                      'env': 'prod',
                                      'kind': 'pod',
                                      'mesh': '1',
                                      'weight': '10'}
        :rtype: Endpoint
        :raise ServiceDiscoveryError: 调用请求 consul agent，返回状态码非 200 时抛出，服务列表为空也会抛出
        :raise ConnectionRefusedError: 连接 consul agent 失败时抛出，如果为 macOS 开发环境，请尝试设置 ``CONSUL_HTTP_HOST`` 环境变量解决
        """
        hosts = self.lookup_name(name, timeout, cachetime, cluster)
        return self._get_one(hosts, name, env=env, envs=envs)

    def _get_one(self, hosts, name, env=None, envs=None):
        if not hosts:
            raise ServiceDiscoveryError("hosts is empty, psm name is %s" % name)

        if env and envs:
            raise ValueError("not support use params 'env' and 'envs' together")

        if env is not None:
            envs = [env]

        if envs:
            hosts = [x for x in hosts if x.tags.get("env") in envs]
            if not hosts:
                msg = "hosts is empty with specified env, psm name is %s, env is %s" % (name, ", ".join(envs))
                raise ServiceDiscoveryError(msg)

        w = []
        can_weight = False
        for host in hosts:
            if "Tags" in host and "weight" in host["Tags"] and host["Tags"]["weight"] != "":
                w.append(int(host["Tags"]["weight"]))
                can_weight = True
            else:
                w.append(50)
        if can_weight:
            return weight_choices(hosts, weights=w)
        return random.choice(hosts)


client = Client()
set_address_family = client.set_address_family
set_dualstack_unique = client.set_dualstack_unique
lookup = client.lookup
lookup_name = client.lookup_name
register = client.register
deregister = client.deregister
get_one = client.get_one
get_one_name = client.get_one_name
