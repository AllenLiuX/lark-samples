# coding: utf-8

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals


import copy
import functools
from multiprocessing.pool import Pool as OriginProcessPool
import types
from .context import global_context

class WrapContext:
    """Use class decorator here, because the pickle module can't dump function closures.
    """
    def __init__(self, func):
        functools.wraps(func)(self)
        self.context_store = copy.deepcopy(getattr(global_context.thread_local, "store", {}))
        self.__origin_func = func
 
    def __call__(self, *args, **kwargs):
        global_context.thread_local.store = self.context_store
        try:
            return self.__wrapped__(*args, **kwargs)
        except AttributeError:
            return self.__origin_func(*args, **kwargs)
 
    def __get__(self, instance, cls):
        if instance is None:
            return self
        return types.MethodType(self, instance)


class ProcessPool(OriginProcessPool):

    """Drop-in replacement for ``multiprocessing.Pool``, which will pass context to new process.
    """
    def apply(self, func, *args, **kwargs):
        return super(ProcessPool, self).apply(WrapContext(func), *args, **kwargs)

    def apply_async(self, func, *args, **kwargs):
        return super(ProcessPool, self).apply_async(WrapContext(func), *args, **kwargs)

    def map(self, func, *args, **kwargs):
        return super(ProcessPool, self).map(WrapContext(func), *args, **kwargs)

    def map_async(self, func, *args, **kwargs):
        return super(ProcessPool, self).map_async(WrapContext(func), *args, **kwargs)

    def imap(self, func, *args, **kwargs):
        return super(ProcessPool, self).imap(WrapContext(func), *args, **kwargs)

    def imap_unordered(self, func, *args, **kwargs):
        return super(ProcessPool, self).imap_unordered(WrapContext(func), *args, **kwargs)
