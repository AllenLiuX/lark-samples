# coding: utf-8
from __future__ import absolute_import, division, print_function, unicode_literals

import ipaddress
import json
import os
import threading
import time
from threading import RLock

from .callcache import callcache

UNKNOWN_REGION = '-'

# Copied from https://code.byted.org/gopkg/env/blob/master/idc.go
UNKNOWN_IDC = '-'
DC_BR = "br"
DC_JP = "jp"
DC_IN = "in"
DC_FRAWS = "fraws"  # 未确认的法兰克福机房
DC_MAWSJP = "mawsjp"  # musical.ly 东京老机房
DC_AGCQ = "agcq"
DC_AGGDSZ = "aggdsz"
DC_AGHBWH = "aghbwh"
DC_AGJSNJ = "agjsnj"
DC_AGLNSY = "aglnsy"
DC_AGSDQD = "agsdqd"
DC_AGSXLQ = "agsxlq"
DC_AGSXXA = "agsxxa"
DC_AGSY = "agsy"
DC_ALIEC1 = "aliec1"
DC_ALIEC2 = "aliec2"
DC_ALIGDSZ = "aligdsz"
DC_ALINC2 = "alinc2"  # aliyun north
DC_ALISC1 = "alisc1"
DC_ALISG = "alisg"  # Singapore Aliyun
DC_ALISH = "alish"
DC_ALIVA = "aliva"
DC_AWSBH = "awsbh"
DC_AWSBR = "awsbr"
DC_AWSFR = "awsfr"  # 法兰克福
DC_AWSIN = "awsin"
DC_AWSJP = "awsjp"
DC_AWSJPGM = "awsjpgm"
DC_AWSNC1 = "awsnc1"
DC_AWSNWC1 = "awsnwc1"
DC_AWSSG = "awssg"
DC_AWSSGGM = "awssggm"
DC_AWSVAC = "awsvac"
DC_AWSVAGM = "awsvagm"
DC_BJGS = "bjgs"
DC_BJLGY = "bjlgy"
DC_BOE = "boe"  # bytedance offline environment
DC_BOEXFL = "boexfl"  # volcano cloud xfl offline enviroment
DC_IBOE = "boei18n"  # bytedance offline environment(international)
DC_BOEI18N = DC_IBOE  # Notice: idc.go have no this alias.
DC_CA = "ca"  # West America
DC_COF = "cof"
DC_DEVBOX = "devbox"
DC_DEVBOXI18N = "devboxi18n"
DC_GALINC2 = "galinc2"
DC_GALISG = "galisg"
DC_GALIVA = "galiva"
DC_GCPAU = "gcpau"
DC_GCPBE = "gcpbe"
DC_GCPBR = "gcpbr"
DC_GCPCA = "gcpca"
DC_GCPCH = "gcpch"
DC_GCPDE = "gcpde"
DC_GCPFI = "gcpfi"
DC_GCPGB = "gcpgb"
DC_GCPHK = "gcphk"
DC_GCPIN = "gcpin"
DC_GCPJPOSA = "gcpjposa"
DC_GCPJPTKY = "gcpjptky"
DC_GCPNL = "gcpnl"
DC_GCPSG = "gcpsg"
DC_GCPTW = "gcptw"
DC_GCPUSCBF = "gcpuscbf"
DC_GCPUSIAD = "gcpusiad"
DC_HKCJ = "hkcj"
DC_HL = "hl"
DC_HY = "hy"
DC_KSRU = "ksru"
DC_LF = "lf"
DC_LQ = "lq"  # 灵丘机房
DC_MALIVA = "maliva"
DC_QDTOB = "qdtob"
DC_QDTOBIAAS = "qdtobiaas"
DC_SDQD = "sdqd"
DC_SG = "sg"
DC_SG1 = "sg1"
DC_SGCOMM1 = "sgcomm1"
DC_SGEA1 = "sgea1"
DC_SGEA2 = "sgea2"
DC_SGEE1 = "sgee1"
DC_SGEE2 = "sgee2"
DC_SGEE3 = "sgee3"
DC_SGSAAS1LARKIDC1 = "sgsaas1larkidc1"
DC_SGSAAS1LARKIDC2 = "sgsaas1larkidc2"
DC_SGSAAS1LARKIDC3 = "sgsaas1larkidc3"
DC_SYKA2LARK = "syka2lark"  # 顺义KA2机房(lark)
DC_SYKA3LARK = "syka3lark"
DC_SYKALARK = "sykalark"  # 顺义KA机房(lark)
DC_USEAST2A = "useast2a"  # 美东第二机房
DC_USEAST3 = "useast3"
DC_USEAST4 = "useast4"
DC_USEAST5 = "useast5"
DC_USEAST8 = "useast8"
DC_USWEST1A = "uswest1a"
DC_VA = "va"
DC_WJ = "wj"
DC_YCRU = "ycru"
DC_MY = "my"
DC_IE = "ie"


@callcache
def get_idc_name():  # type: () -> str
    """Get current machine's IDC name.

    Notice that this function is not reliable, so this function should be used for metrics information.

    :returns: IDC name or '-'
    :rtype: str
    """
    name = os.environ.get('RUNTIME_IDC_NAME')
    if name:
        return name

    try:
        with open('/opt/tmp/consul_agent/datacenter') as f:
            content = f.read()
            return content.strip()
    except IOError:
        pass

    try:
        idc_name = os.popen('/opt/tiger/consul_deploy/bin/determine_dc.sh 2> /dev/null').read().strip()
        if idc_name and has_idc(idc_name):
            return idc_name
    except Exception:
        pass

    try:
        cmd = '/opt/tiger/ss_lib/bin/sd report 2> /dev/null |grep "Data center"|awk \'{print $3}\''
        idc_name = os.popen(cmd).read().strip()
        if idc_name and has_idc(idc_name):
            return idc_name
    except Exception:
        pass

    return UNKNOWN_IDC


class IDCInfo(object):
    def __init__(self):
        self._net_segment_path = ["/opt/tmp/consul_agent/netsegment", "/opt/tiger/chadc/netsegment"]
        self._net_segment6_path = ["/opt/tmp/consul_agent/netsegment6", "/opt/tiger/chadc/netsegment6"]
        self._refresh_interval = 60 * 5

        self.IPV4_segments = []
        self.IPV6_segments = []

        # Loads netsegment information.
        self._lock = threading.Lock()
        self._last_refresh_time = None

    def refresh_net_segment_cache(self):
        # Refresh netsegment.
        segment_content = set()
        for path in self._net_segment_path:
            try:
                with open(path) as f:
                    segment_content.update(f.read().split("\n"))
            except IOError:  # Invalid netsegment path.
                pass

        for info in segment_content:
            parts = info.split(" ")
            if len(parts) != 2:  # Invalid segment format.
                continue

            try:
                segment, region = ipaddress.ip_interface(parts[0]), parts[1]
            except ValueError:  # Invalid segment format.
                continue

            if segment.version == 4:
                self.IPV4_segments.append((segment, region))

        # Refresh netsegment6.
        segment6_content = set()
        for path in self._net_segment6_path:
            try:
                with open(path) as f:
                    segment6_content.update(f.read().split("\n"))
            except IOError:  # Invalid netsegment6 path.
                pass

        for info in segment6_content:
            parts = info.split(" ")
            if len(parts) != 2:  # Invalid segment format.
                continue

            try:
                segment, region = ipaddress.ip_interface(parts[0]), parts[1]
            except ValueError:  # Invalid segment format.
                continue

            if segment.version == 6:
                self.IPV6_segments.append((segment, region))

        # Sort segments.
        self.IPV4_segments.sort(key=lambda x: x[0])
        self.IPV6_segments.sort(key=lambda x: x[0])

        self._last_refresh_time = time.time()

    def get_idc_from_ip(self, ip):
        # Refresh cache if it has expired.
        if self._last_refresh_time is None or time.time() - self._last_refresh_time >= self._refresh_interval:
            with self._lock:
                self.refresh_net_segment_cache()

        try:
            ip_interface = ipaddress.ip_interface(ip)
        except ValueError:  # Invalid input ip.
            return UNKNOWN_IDC

        with self._lock:
            if ip_interface.version == 4:
                return self._traversal_search(self.IPV4_segments, ip_interface)
            elif ip_interface.version == 6:
                return self._traversal_search(self.IPV6_segments, ip_interface)

        return UNKNOWN_IDC

    @staticmethod
    def _binary_search(ip_segments, ip_interface):
        start, end = 0, len(ip_segments)
        while start < end:
            mid = ((end - start) >> 1) + start
            segment, region = ip_segments[mid]
            if int(segment) == int(ip_interface) & int(segment.netmask):
                return region
            if segment < ip_interface:
                start = mid + 1
            else:
                end = mid
        return UNKNOWN_IDC

    @staticmethod
    def _traversal_search(ip_segments, ip_interface):
        res = []
        for i in ip_segments:
            segment, region = i
            if int(segment) == int(ip_interface) & int(segment.netmask):
                res.append(i)

        if not res:
            return UNKNOWN_IDC
        res.sort(key=lambda x: x[0], reverse=True)
        return res[0][1]


defaultIDCInfo = IDCInfo()


def get_idc_from_ip(ip):  # type: (str) -> str
    """Get IDC name from the input ip.

    :param ip: ipv4 or ipv6 address.
    :type ip: str
    :return: IDC name.
    :rtype: str
    """
    return defaultIDCInfo.get_idc_from_ip(ip)


class Region(object):
    def __init__(self):
        self._region_file_path = '/opt/tiger/chadc/region.json'
        self._refresh_interval = 60 * 5

        self._lock = RLock()
        self._region_idc_from_file = {}
        self._last_refresh_time = None

    def get_region_from_idc(self, idc):  # type: (str) -> str
        """Get the region of the idc

        :param idc:
        :type idc: str
        :return: the region of the idc
        :rtype: str
        """
        with self._lock:
            if self._last_refresh_time is None or time.time() - self._last_refresh_time > self._refresh_interval:
                try:
                    with open(self._region_file_path) as f:
                        self._region_idc_from_file = json.load(f)
                except Exception:
                    pass

                self._last_refresh_time = time.time()

            for region, idc_list in self._region_idc_from_file.items():
                if idc in idc_list:
                    return region

        return UNKNOWN_REGION

    def get_region(self):  # type: () -> str
        """Get the region of current idc

        :return: current region
        :rtype: str
        """
        return self.get_region_from_idc(get_idc_name())

    def has_idc(self, idc):  # type: (str) -> bool
        """Check it out that whether the idc exists or not.

        Notice that it can return False if the region-idc file doesn't get updated or exist.

        :param idc:
        :return: whether idc exists in the region-idc file or not
        :rtype: bool
        """
        return self.get_region_from_idc(idc) != UNKNOWN_REGION


default_region = Region()

get_region = default_region.get_region
has_idc = default_region.has_idc
get_region_from_idc = default_region.get_region_from_idc
